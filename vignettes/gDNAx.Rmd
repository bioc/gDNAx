---
title: "The gDNAx package"
author:
- name: Beatriz Calvo-Serra
  affiliation:
  - &id Dept. of Medicine and Life Sciences, Universitat Pompeu Fabra, Barcelona, Spain
  email: beatriz.calvo@upf.edu
- name: Robert Castelo
  affiliation: *id
  email: robert.castelo@upf.edu
package: "`r pkg_ver('gDNAx')`"
abstract: >
  The `gDNAx` package provides functionality to diagnose the presence of genomic DNA (gDNA) contamination in RNA-seq data sets, and filter out reads of potential gDNA origin.
vignette: >
  %\VignetteIndexEntry{The gDNAx package}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
output:
  BiocStyle::html_document:
    toc: true
    toc_float: true
    number_sections: true
bibliography: bibliography.bib
---

```{r setup, echo=FALSE}
library(knitr)

options(width=80)

knitr::opts_chunk$set(
    collapse=TRUE,
    comment="")
```

# What is genomic DNA contamination in a RNA-seq experiment

Genomic DNA (gDNA) contamination is an internal contaminant that can be 
present in gene quantification techniques, such as in an RNA-sequencing 
(RNA-seq) experiment. This contamination can be due to an absent or inefficient
gDNA digestion step (with DNase) during RNA extraction or library preparation.
In fact, some protocols do not include a DNase treatment step, or they include
it as optional.

While gDNA contamination is not a major issue for poly(A) RNA-seq, it can
remarkably affect gene expression quantification of total RNA-seq experiments.
Moreover, gDNA contamination can lead to a misleading attribution of expression
to unannotated regions of the genome. For this reason, it is important to check
the levels of gDNA contamination during quality control before performing
further analyses, specially when total RNA has been sequenced.

# Diagnose the presence of gDNA contamination

Here we illustrate the use of the `gDNAx` package for producing different
diagnostics and how do they reveal different gDNA contamination levels. We use
a subset of the data in [@li2022genes], which consists of 9 paired-end samples
of total RNA-seq with increasing levels of gDNA contamination: 0% (no
contamination), 1% and 10%, with 3 replicates each. The data is available
through the experiment data package
[gDNAinRNAseqData](https://bioconductor.org/packages/gDNAinRNAseqData), which
allows one to download 9 BAM files, containing about 100,000 alignments, sampled
uniformly at random from the complete BAM files.

```{r, message=FALSE}
library(gDNAinRNAseqData)

# Retrieve BAM files
bamfiles <- LiYu22subsetBAMfiles()
bamfiles

# Retrieve information on the gDNA concentrations of each BAM file
pdat <- LiYu22phenoData(bamfiles)
pdat
```

Diagnosing the presence of gDNA contamination requires using an annotation
of genes and transcripts. The `gDNAx` package expects that we provide such
an annotation using a so-called `TxDb` package, either as a `TxDb` object,
created once such a package is loaded in the R session, or by specifying the
name of the package. The Bioconductor
[website](https://www.bioconductor.org/packages/release/BiocViews.html#___TxDb)
provides a number of `TxDb` packages, but if the we do not find the one we are
looking for, we can build a `TxDb` object using the function `makeTxDbFromGFF()`
from a given [GFF](https://en.wikipedia.org/wiki/General_feature_format) or
[GTF](https://en.wikipedia.org/wiki/Gene_transfer_format) file, or any of the
other `makeTxDbFrom*()` functions, available in the
[GenomicFeatures](https://bioconductor.org/packages/GenomicFeatures) package.
Here we load the `TxDb` package corresponding to the GENCODE annotation provided
by the UCSC Genome Browser.

```{r, message=FALSE}
library(TxDb.Hsapiens.UCSC.hg38.knownGene)

txdb <- TxDb.Hsapiens.UCSC.hg38.knownGene
```

We can calculate diagnostics for gDNA contamination using the function
`gDNAdx()` from the `gDNAx` package, as follows.

```{r, message=FALSE}
library(gDNAx)

gdnax <- gDNAdx(bamfiles, txdb)
class(gdnax)
gdnax
```

The previous call will report progress through its calculations unless we set
the argument `verbose=FALSE`, and return an object of class `gDNAx` once it has
finished. Calling the `plot()` function with that object as the first argument
will plot several diagnostics. Here below, we also use a parameter called
`group` to automatically color samples, in this case, by the gDNA contamination
levels included in the experimental design of the data; see [@li2022genes] for
full details on it.


```{r defdiag, height=12, width=10, out.width="800px", fig.cap="Default diagnostics by the function `plot()` on a `gDNAx` object."}
par(mar=c(4, 5, 2, 1))
plot(gdnax, group=pdat$gDNA, pch=19)
```

The previous figure contains three diagnostic plots, each one showing the
following values as a function of the percentage of intergenic alignments:

* Percentage of **Splice-compatible junction** (SCJ) alignments. These are
  alignments compatible with a transcript in the given annotation, for which
  the aligned read, or at least one of the two aligned reads in the case of
  a paired-end layout, spans an exon-exon junction over two exons of that
  transcript.
* Percentage of **splice compatible exonic** (SCE) alignments. These are
  alignments compatible with a transcript in the given annotation, but which
  differently to SCJ alignments, do not include an exon-exon junction in the
  alignment.
* Percentage of **intronic** (INT) alignments. These are alignments fully
  contained in intergenic regions.

These data appear to come from an unstranded library, but if they would be
stranded, a fourth diagnostic plot would appear showing an estimated value of
the strandedness of each sample as function of the percentage of intergenic
alignments. In stranded RNA-seq data, we should expect strandedness values close
to 1, which imply that most reads align to the same strand than the annotated
transcripts. Lower strandedness values can be indicative of gDNA contamination
because reads sequenced from DNA are expected to align in equal proportions to
both strands.

Because **intergenic** (IGC) alignments mainly originate from gDNA contamination,
we may expect a negative correlation between the percentage of SCJ or SCE
alignments and the percentage of IGC alignments. On the other hand, INT
alignments may originate either from primary unprocessed transcripts in the
nucleous, or from gDNA contamination as well. Therefore, we may also expect some
positive correlation between the percentages of INT and IGC alignments, as it
happens in this data.

Using the function `getDx()` on the `gDNAx` object, we obtain all the values
used in the diagnostics.

```{r}
dx <- getDx(gdnax)
dx
```

Strandedness values are stored in the `STRAND` column and in this case are `NA`
because the dataset is not strand-specific.

## Strandedness estimation

Since we have let the `gDNAdx()` function to estimate strandedness, we can
examine those estimated values using the getter function `strandedness()` on
the `gDNAx` object.

```{r, message=FALSE}
strandedness(gdnax)
```

As we can see, the proportion of alignments overlapping
transcripts when `strandMode = 1L` is used ("strandMode1" column) 
is very similar to the one when `strandMode = 2L` is considered
("strandMode2" column), which is compatible with a non-stranded library.
This contrasts with the reported stranded protocol used to obtain this data
according to [@li2022genes]. However, the results obtained by
`identifyStrandMode()` were contrasted with results of the RSeQC 
`infer_experiment.py` tool ([@wang2012rseqc]) and visual inspection of data
in the Integrative Genomics Viewer (IGV) ([@robinson2011integrative]), all
of which point to an unstranded RNA-seq experiment.

`identifyStrandMode()` uses 200,000 alignments overlapping exonic regions to
compute strandedness (recommended by [@signal2022how_are_we_stranded_here]),
unless the number of these kind of alignments in the BAM file is lower. 
In this vignette, the number of alignments used is close to 60,000, which is
the total number of exonic alignments present in the BAM files.

If we are only interested in the estimation of strandedness values, we can
can also call `strandedness()` with a character string vector of BAM filenames
and a `TxDb` annotation object; see help page of `strandedness()`.


Another plot to represent diagnostic measures is the one representing the 
origin of alignments per sample. Fluctuations in this proportions
evidence different levels of gDNA contamination in samples.

```{r alnorigins, height=4, width=8, out.width="800px", fig.cap="Alignment origins."}
plotAlnOrigins(gdnax, group=pdat$gDNA)
```

Finally, the estimated fragments length distributions can be plotted with
`plotFrgLength()`. This plot can show any differences in fragment length
distributions that may be present. This plot is only available for 
paired-end data.

```{r frglen, height=4, width=8, out.width="800px", fig.cap="Estimated fragments length distributions."}
plotFrgLength(gdnax)
```

## Accessing annotations

The annotations of intergenic and intronic regions used to compute these
diagnostics can easily be obtain using two different functions: `getIgc()` and
`getInt`, respectively. For instance, let's retrieve intergenic annotations:

```{r}
igc <- getIgc(gdnax)
head(igc, n=3)
```

# Filter alignments according to an annotation

The package also provides functions to filter splice-compatible alignments
and write them into new BAM files. To do so, first we set the type
of alignments to be included in the BAM file using `filterBAMtxFlag()`, and
then we call the `filterBAMtx()` function. For instance, to keep only reads
expected to come from RNA, we can set `isSpliceCompatibleJunction` and
`isSpliceCompatibleExonic` to `TRUE`. The resulting BAM files, which are
located in the directory indicated in the `path` argument, are
useful for performing downstream analyses, such as differential expression
analysis, without the effect of gDNA contamination.

```{r, eval=FALSE}
fbf <- filterBAMtxFlag(isSpliceCompatibleJunction=TRUE,
                       isSpliceCompatibleExonic=TRUE)
tmpdir <- tempdir()
fstats <- filterBAMtx(gdnax, path=tmpdir, txflag=fbf)
# list.files(tmpdir, pattern="*.bam$")
fstats
```

```{r, echo=FALSE}
fstats_f <- file.path(system.file("extdata", package="gDNAx"),
                      "filterBAMtx_fstats.rds")
fstats <- readRDS(fstats_f)
fstats
```

We can see the number of alignments in each of the selected categories, and
`NA` for those for which we did not retrieve any alignment.

# Session information

```{r session_info, cache=FALSE}
sessionInfo()
```

# References
